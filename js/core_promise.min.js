!function(t){t.BX||(t.BX={});var e=t.BX;e.Promise=function(t,e){this.state=null,this.value=null,this.reason=null,this.next=null,this.ctx=e||this,this.onFulfilled=[],this.onRejected=[]},e.Promise.prototype.fulfill=function(t){this.checkState(),this.value=t,this.state=!0,this.execute()},e.Promise.prototype.reject=function(t){this.checkState(),this.reason=t,this.state=!1,this.execute()},e.Promise.prototype.then=function(t,i){return("function"==typeof t||t instanceof Function)&&this.onFulfilled.push(t),("function"==typeof i||i instanceof Function)&&this.onRejected.push(i),null===this.next&&(this.next=new e.Promise(null,this.ctx)),null!==this.state&&this.execute(),this.next},e.Promise.prototype.catch=function(t){return("function"==typeof t||t instanceof Function)&&this.onRejected.push(t),null===this.next&&(this.next=new e.Promise(null,this.ctx)),null!==this.state&&this.execute(),this.next},e.Promise.prototype.setAutoResolve=function(t,e){this.timer=setTimeout(function(){null===this.state&&this[t?"fulfill":"reject"]()}.bind(this),e||15)},e.Promise.prototype.cancelAutoResolve=function(){clearTimeout(this.timer)},e.Promise.prototype.resolve=function(t){var e=this;this===t?this.reject(new TypeError("Promise cannot fulfill or reject itself")):t&&"[object BX.Promise]"===t.toString()?t.then((function(t){e.fulfill(t)}),(function(t){e.reject(t)})):this.fulfill(t)},e.Promise.prototype.toString=function(){return"[object BX.Promise]"},e.Promise.prototype.execute=function(){if(null!==this.state){var i,o=void 0,n=void 0,s=void 0;if(!0===this.state)if(this.onFulfilled.length)try{for(i=0;i<this.onFulfilled.length;i++)void 0!==(s=this.onFulfilled[i].apply(this.ctx,[this.value]))&&(o=s)}catch(o){"console"in t&&console.dir(o),void 0!==e.debug&&e.debug(o),n=o}else o=this.value;else if(!1===this.state)if(this.onRejected.length)try{for(i=0;i<this.onRejected.length;i++)void 0!==(s=this.onRejected[i].apply(this.ctx,[this.reason]))&&(o=s)}catch(o){"console"in t&&console.dir(o),void 0!==e.debug&&e.debug(o),n=o}else n=this.reason;null!==this.next&&(void 0!==n?this.next.reject(n):void 0!==o&&this.next.resolve(o))}},e.Promise.prototype.checkState=function(){if(null!==this.state)throw new Error("You can not do fulfill() or reject() multiple times")}}(window);